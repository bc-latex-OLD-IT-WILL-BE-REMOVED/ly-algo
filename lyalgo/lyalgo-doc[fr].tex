%\documentclass[12pt,a4paper]{scrartcl}
\documentclass[12pt,a4paper]{article}

\makeatletter % Technical doc - START

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{dsfont}

\usepackage[french]{babel,varioref}

\usepackage[top=2cm, bottom=2cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage{enumitem}

\usepackage{color}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{ifplatform}
\usepackage{import}

\usepackage{multicol}

\usepackage{tcolorbox}

\usepackage{amsthm}

\usepackage{ifplatform}

\usepackage{cbdevtool}
\usepackage{lymath}

% MISC

\setlength{\parindent}{0cm}
\setlist{noitemsep}


\theoremstyle{definition}
\newtheorem*{remark}{Remarque}


\usepackage[raggedright]{titlesec}

\titleformat{\paragraph}[hang]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{0.5em}

\setlength{\parindent}{0cm}

\newenvironment{frame-gene}[1][]{
	\begin{tcolorbox}[
		title        = #1, 
		colbacktitle = black!10!white, 
		colback      = white, 
		coltitle     = black,
		fonttitle    = \bfseries\itshape\small, 
		breakable,
		center title]
}{
	\end{tcolorbox}
}

\newcommand\myquote[1]{{\itshape \og #1 \fg}}

\newcommand\squaremacro{$x^2$}

\makeatother % Technical doc - END


\usepackage{lyalgo}


\begin{document}

\renewcommand\labelitemi{\raisebox{0.125em}{\tiny\textbullet}}
\renewcommand{\labelitemii}{---}

\title{%
	Le package \texttt{lyalgo}:
	\\
	taper facilement de jolis algorithmes
	\\
	{
		\footnotesize Code source disponible
		sur \url{https://github.com/bc-latex/ly-algo}.%
	}
	\\
	{
		\footnotesize Version \texttt{0.1.0-beta}
		développée et testée sur \macosxname{}.%
	}
}

\author{Christophe BAL}
\date{2019-10-20}

\maketitle


\vspace{2em}

\hrule

\tableofcontents

\vspace{1.5em}

\hrule

\newpage



\section{Introduction}

Le but de ce package est d'avoir facilement des algorithmes
\footnote{
	Le gros du travail est fait par \texttt{algorithm2e}.
}
ainsi que des contenus \verb+verbatim+ un peu flexibles
\footnote{
	Tout, ou presque, est géré par \texttt{alltt}.
}.
Les algorithmes mis en forme ne sont pas des flottants, par choix, et ils utilisent une mise en forme proche de la syntaxe \verb+Python+.




\section{\texttt{lymath}, un package qui vous veut du bien}

Le package \verb+lymath+ est un bon complément à \verb+lyalgo+ : voir à l'adresse \url{https://github.com/bc-latex/ly-math}. 
Il est utilisé par cette documentation pour simplifier la saisie des formules.




\section{Écriture \texttt{pseudo-verbatim}}

En complément à l'environnement \verb+verbatim+ est proposé l'environnement \verb+pseudoverb+, pour \og pseudo verbatim \fg, qui permet d'écrire du contenu presque verbatim : ci-après, la macro \verb+\squaremacro+ définie par \verb+\newcommand\squaremacro{$x^2$}+ est interprétée mais pas la formule mathématique. 

\begin{frame-gene}[Code \LaTeX]
	\small
	\begin{verbatim}
\begin{pseudoverb*}
  Prix1 = 14 euros 
+ Prix2 = 30 euros
-------------------
  Total = 44 euros

========
Remarque
========
Attention car les macros comme \squaremacro{} sont interprétées mais pas les formules
de maths comme $x^2$ !
\end{pseudoverb*} 
	\end{verbatim}
\end{frame-gene}


La mise en forme correspondante est la suivante sans cadre autour.

\begin{frame-gene}[Rendu réel\\ATTENTION ! Le cadre ne fait pas partie de la mise en forme.]
	\begin{pseudoverb*}
  Prix1 = 14 euros
+ Prix2 = 30 euros
-------------------
  Total = 44 euros

========
Remarque
========
Attention car les macros comme \squaremacro{} sont interprétées mais pas les formules
de maths comme $x^2$ !
	\end{pseudoverb*} 
\end{frame-gene}


\medskip


Il est en fait plus pratique de pouvoir taper quelque chose comme ci-dessous avec un cadre autour où le titre est un argument obligatoire \emph{(voir plus bas comment ne pas avoir de titre)}.

\begin{pseudoverb}{Une sortie console}
  Prix1 = 14 euros
+ Prix2 = 30 euros
-------------------
  Total = 44 euros
\end{pseudoverb} 


Le contenu précédent s'obtient via le code suivant.

\begin{frame-gene}[Code \LaTeX]
	\small
	\begin{verbatim}
\begin{pseudoverb}{Une sortie console}
  Prix1 = 14 euros
+ Prix2 = 30 euros
-------------------
  Total = 44 euros
\end{pseudoverb} 
	\end{verbatim} 
\end{frame-gene}


Finissons avec une version bien moins large et sans titre de la sortie console ci-dessus. Le principe est de donner un titre vide via \verb+{}+, \textbf{c'est obligatoire}, et en utilisant l'unique argument optionnel pour indiquer la largeur relativement à celle des lignes.
En utilisant juste \verb+\begin{pseudoverb}[.275]{}+ au lieu de \verb+\begin{pseudoverb}{Une sortie console}+, le code précédent nous donne ce qui suit.


\begin{pseudoverb}[.275]{}
  Prix1 = 14 euros
+ Prix2 = 30 euros
-------------------
  Total = 44 euros
\end{pseudoverb} 


\bigskip


\begin{frame-gene}[À RETENIR]
	\centering\itshape
	C'est la version étoilée de \verb+pseudoverb+ qui en fait le moins.
	
	Ce principe sera aussi suivi pour les algorithmes. 
\end{frame-gene}




\section{Algorithmes en langage naturel}

\subsection{Comment taper les algorithmes}

Le package \verb+algorithm2e+ permet de taper des algorithmes avec une syntaxe simple. La mise en forme par défaut de \verb+algorithm2e+ utilise des flottants, chose qui peut poser des problèmes pour de longs algorithmes ou, plus gênant, pour des algorithmes en bas de page. Dans \verb+lyalgo+, il a été fait le choix de ne pas utiliser de flottants, un choix lié à l'utilisation faite de \verb+lyalgo+ par l'auteur pour rédiger des cours de niveau lycée. 


\medskip

Dans la section suivante, nous verrons comment encadrer les algorithmes. Pour l'instant, voyons juste comment taper l'algorithme suivant où tous les mots clés sont en français. Indiquons au passage l'affichage du titre de l'algorithme en haut et non en bas comme cela est proposé par défaut.


\bigskip


\begin{algo*}
    \caption{Suite de Collatz $(u_k)$ -- Conjecture de Syracuse}

    \Data{$n \in \NN$}
    \Result{le premier indice $i \in \ZintervalC{0}{10^5}$ tel que $u_i = 1$ ou $(-1)$ en cas d'échec}

    \addalgoblank    % Pour aérer un peu la mise en forme.

    \Actions{
        $i, imax \Store 0, 10^5$
        \\
        $u \Store n$
        \\
        $continuer \Store \top$
        \\
        \While{$continuer = \top \And i \leq imax$}{
            \uIf{$u = 1$}{
                \Comment{C'est gagné !}
                $continuer \Store \bot$
            } \Else {
                \Comment{Calcul du terme suivant}
                \uIf{$u \equiv 0 \,\, [2]$}{
                    $u \Store u / 2$
                    \Comment*{Quotient de la division euclidienne.}
                } \Else {
                    $u \Store 3u + 1$
                }
                $i \Store i + 1$
            }
        }
        \If{$i > imax$}{
            $i \Store (-1)$
        }
        \Return{$i$}
    }
\end{algo*}


\bigskip


La rédaction d'un tel algorithme est facile car il suffit de taper le code suivant proche de ce que pourrait proposer un langage classique de programmation. Le code utilise certaines des macros additionnelles proposées par \verb+lyalgo+ \emph{(voir la section \ref{algo-extra})} ainsi que la macro \verb+\ZintervalC+ du package \verb+lymath+. Nous donnons juste après le squelette de la syntaxe propre à \verb+algorithm2e+.


\begin{frame-gene}[Code \LaTeX]
    \small
\begin{verbatim}
\begin{algo*}
    \caption{Suite de Collatz $(u_k)$ -- Conjecture de Syracuse}

    \Data{$n \in \NN$}
    \Result{le premier indice $i \in \ZintervalC{0}{10^5}$ tel que $u_i = 1$ ou $(-1)$
            en cas d'échec}

    \addalgoblank    % Pour aérer un peu la mise en forme.

    \Actions{
        $i, imax \Store 0, 10^5$
        \\
        $u \Store n$
        \\
        $continuer \Store \top$
        \\
        \While{$continuer = \top$ \And $i \leq imax$}{
            \uIf{$u = 1$}{
                \Comment{C'est gagné !}
                $continuer \Store \bot$
            } \Else {
                \Comment{Calcul du terme suivant}
                \uIf{$u \equiv 0 \,\, [2]$}{
                    $u \Store u / 2$
                    \Comment*{Quotient de la division euclidienne.}
                } \Else {
                    $u \Store 3u + 1$
                }
                $i \Store i + 1$
            }
        }
        \If{$i > imax$}{
            $i \Store (-1)$
        }
        \Return{$i$}
    }
\end{algo*}
\end{verbatim}
\end{frame-gene}


Le squelette du code précédent est le suivant. 


\begin{frame-gene}[Squelette du code \texttt{algorithm2e}]
    \small
\begin{verbatim}
\caption{...}

\Data{...}
\Result{...}

\Actions{
    ...
    \While{...}{
        \uIf{...}{
            ...
        } \Else {
            ...
            \uIf{...}{
                ...
            } \Else {
                ...
            }
            ...
        }
    }
    \If{...}{
        ...
    }
    \Return{...}
}
\end{verbatim}
\end{frame-gene}




%\section{Algorithmes en langage naturel}

\subsection{Numérotation des algorithmes}


Avant de continuer les présentations, il faut savoir que les algorithmes sont numérotés globalement à l'ensemble du document. C'est plus simple et efficace pour une lecture sur papier.




%\section{Algorithmes en language naturel}

\subsection{Des algorithmes encadrés}

La version non étoilée de l'environnement \verb+algo+ ajoute un cadre, comme ci-dessous, afin de rendre plus visibles les algorithmes.

\begin{algo}
    \caption{Un truc bidon}

    \Data{$n \in \NNs$}
    \addalgoblank
    \Result{$\dsum_{i = 1}^{n} i$}

    \Actions{
        $s \Store 0$
        \\
        \ForRange{$i$}{$1$}{$n$}{
            $s \Store s + i$
        }
        \Return{$s$}
    }
\end{algo} 


\medskip


Le code utilisé pour obtenir le rendu précédent est le suivant où sont utilisées certaines des macros additionnelles proposées par \verb+lyalgo+ \emph{(voir la section \ref{algo-extra})} où les macros \verb+\NNs+ et \verb+\dsum+ viennent du package \verb+lymath+.

\begin{frame-gene}[Code \LaTeX]
    \small
    \begin{verbatim}
\begin{algo}
    \caption{Un truc bidon}
    \Data{$n \in \NNs$}
    \addalgoblank
    \Result{$\dsum_{i = 1}^{n} i$}
    \Actions{
        $s \Store 0$
        \\
        \ForRange{$i$}{$1$}{$n$}{
            $s \Store s + i$
        }
        \Return{$s$}
    }
\end{algo}
	\end{verbatim}
\end{frame-gene}


\medskip


L'environnement \verb+algo+ propose un argument optionnel pour indiquer la largeur relativement à celle des lignes.
Ainsi  via \verb+\begin{algo}[.45] ... \end{algo}+, on obtient la version suivante bien moins large de l'algorithme précédent.

\begin{algo}[.45]
    \caption{Un truc bidon}

    \Data{$n \in \NNs$}
    \addalgoblank
    \Result{$\dsum_{i = 1}^{n} i$}

    \Actions{
        $s \Store 0$
        \\
        \ForRange*{$i$}{$1$}{$n$}{
            $s \Store s + i$
        }
        \Return{$s$}
    }
\end{algo} 


\medskip


On peut utiliser un environnement \verb+multicols+ pour un effet sympa.

\begin{multicols}{2}    
\begin{algo}
    \caption{Un truc bidon}

    \Data{$n \in \NNs$}
    \addalgoblank
    \Result{$\dsum_{i = 1}^{n} i$}
    \Actions{
        $s \Store 0$
        \\
        \ForRange*{$i$}{$1$}{$n$}{
            $s \Store s + i$
        }
        \Return{$s$}
    }
\end{algo}


\begin{algo}
    \caption{Un truc bidon}

    \Data{$n \in \NNs$}
    \addalgoblank
    \Result{$\dsum_{i = 1}^{n} i$}
    \Actions{
        $s \Store 0$
        \\
        \ForRange{$i$}{$1$}{$n$}{
            $s \Store s + i$
        }
        \Return{$s$}
    }
\end{algo}
\end{multicols}




%\section{Algorithmes en langage naturel}

\subsection{Un titre minimaliste}

Dans l'exemple ci-dessous on voit un problème à gauche où l'on a utilisé \verb+\caption{}+ avec un argument vide pour la macro \verb+\caption+.
Si vous avec besoin juste de numéroter votre algorithme comme ci-dessous à droite, utiliser à la place \verb+\algovoidcaption+.


\begin{multicols}{2}    
\begin{algo}
    \caption{}

    \Datas{Un titre vide ci-dessus !}
    \Result{\dots}
    \Actions{
        \dots\phantom{X}
        \\
        \phantom{\dots}\vspace{-.75em}
    }
\end{algo}


\begin{algo}
    \algovoidcaption

    \Datas{\dots}
    \Result{\dots}
    \Actions{
        \dots\phantom{X}
        \\
        \phantom{\dots}\vspace{-.75em}
    }
\end{algo}
\end{multicols}




%\section{Algorithmes en langage naturel}

\subsection{Un premier ensemble de macros additionnelles ou francisées}

\begin{frame-gene}[À SAVOIR -- Le préfixe \texttt{u}]
	\centering\itshape
	Certains macros peuvent être préfixées par un \verb+u+ pour \myquote{unclosed} qui signifie \myquote{non fermé}.
	
	Ceci sert à ne pas refermer un bloc via un trait horizontal.
\end{frame-gene}


% == All extra words - START == %
\subsubsection{Entrée / Sortie}

Nous donnons ci-dessous les versions au singulier de tous les mots disponibles de type \myquote{entrée / sortie}.
Excepté pour \verb+\InState+ et \verb+\OutState+, toutes les autres macros ont une version pour le pluriel obtenu en rajoutant un \verb+s+ à la fin du nom de la macro.
Par exemple, le pluriel de \verb+\In+ s'obtient via \verb+\Ins+.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \In{donnée 1}
  \Out{donnée 2}
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \In{donnée 1}
  \Out{donnée 2}
\end{algo}
    \vfill\null
\end{multicols}


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \Data{donnée 1}
  \Result{donnée 2}
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \Data{donnée 1}
  \Result{donnée 2}
\end{algo}
    \vfill\null
\end{multicols}


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \InState{donnée 1}
  \OutState{donnée 2}
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \InState{donnée 1}
  \OutState{donnée 2}
\end{algo}
    \vfill\null
\end{multicols}


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \PreCond{donnée 1}
  \PostCond{donnée 2}
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \PreCond{donnée 1}
  \PostCond{donnée 2}
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Bloc principal}

Voici comment indiquer le bloc principal d'instructions avec deux textes au choix pour le moment.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \Actions{Instruction 1}
  \Begin{Instruction 2}
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \Actions{Instruction 1}
  \Begin{Instruction 2}
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Boucles \TTfor{} et \TTwhile{}}

Voici les boucles de type \TTfor{} et \TTwhile{} proposées par le package.

\newpage


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \For{$i \in uneliste$}{
    Instruction 1
  }
  \ForAll{$i \in uneliste$}{
    Instruction 2
  }
  \ForEach{$i \in uneliste$}{
    Instruction 3
  }
  \While{$i \in uneliste$}{
    Instruction 4
  }
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \For{$i \in uneliste$}{
    Instruction 1
  }
  \ForAll{$i \in uneliste$}{
    Instruction 2
  }
  \ForEach{$i \in uneliste$}{
    Instruction 3
  }
  \While{$i \in uneliste$}{
    Instruction 4
  }
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Boucles \TTrepeat{}}

Voici comment rédiger une boucle du type \TTrepeat{}.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \Repeat{$i \in uneliste$}{
    Instruction 
  }
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \Repeat{$i \in uneliste$}{
    Instruction 
  }
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Disjonction de cas \TTswitch{}}

La syntaxe pour les blocs conditionnels du type \TTswitch{} ne pose pas de difficultés de rédaction.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \Switch{$i$}{
    \uCase{$i = 0$}{Instruction 1}
    \uCase{$i = 1$}{Instruction 2}
    \Case{$i = 2$}{Instruction 3}
  }
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \Switch{$i$}{
    \uCase{$i = 0$}{Instruction 1}
    \uCase{$i = 1$}{Instruction 2}
    \Case{$i = 2$}{Instruction 3}
  }
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Disjonction conditionnelle \TTif{}}

Les blocs conditionnels \TTif{} se rédigent très naturellement.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \uIf{$i = 0$}{
    Instruction 1
  }
  \uElseIf{$i = 1$}{
    Instruction 2
  }
  \Else{
    Instruction 3
  }
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  \uIf{$i = 0$}{
    Instruction 1
  }
  \uElseIf{$i = 1$}{
    Instruction 2
  }
  \Else{
    Instruction 3
  }
\end{algo}
    \vfill\null
\end{multicols}


\subsubsection{Diverses commandes}

Pour finir voici un ensemble de mots supplémentaires qui pourront vous rendre service. Le préfixe \verb+m+ permet d'utiliser des versions maculines des textes proposés.


\begin{multicols}{2}
    \centering
    \begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  A \And B \Or C
  \\ \Return RÉSULTAT
  \\ \Ask "Quelque chose"
  \\ \Print "Quelque chose"
  \\ $k$ \From $1$ \To $n$
  \\ $k$ \ComingFrom $1$ \GoingTo $n$
  \\ $e$ \InThis $\{ 1 , 4 , 16 \}$
  \\ $L$ \LToR
  \\ $L$ \LToRm
  \\ $L$ \RToL
  \\ $L$ \RToLm
\end{algo}
\end{verbatim}
    \end{frame-gene}
    \vfill\null
    \columnbreak
    \textit{Mise en forme correspondante.}
\begin{algo}
  A \And B \Or C
  \\ \Return RÉSULTAT
  \\ \Ask "Quelque chose"
  \\ \Print "Quelque chose"
  \\ $k$ \From $1$ \To $n$
  \\ $k$ \ComingFrom $1$ \GoingTo $n$
  \\ $e$ \InThis $\{ 1 , 4 , 16 \}$
  \\ $L$ \LToR
  \\ $L$ \LToRm
  \\ $L$ \RToL
  \\ $L$ \RToLm
\end{algo}
    \vfill\null
\end{multicols}


% == All extra words - END == %


% ---------------- %


\subsection{Citer les outils de base en algorithmique}

Pour faciliter la rédaction de textes sur les algorithmes, des macros standardisent l'impression des noms des outils classiques de contrôle.
Dans les exemples qui suivent, les préfixes \verb+TT+ et \verb+AL+ font référence à \myquote{True Type} pour une police à chasse fixe, et à \myquote{AL-gorithme} pour une écriture similaire à celle utilisée dans les algorithmes.


% == Main tools - START == %

\begin{center}
	Liste des commandes de type \myquote{True Type}.
\end{center}

\begin{enumerate}
    \item \verb+\TTif+ donne \TTif.
    \item \verb+\TTfor+ donne \TTfor.
    \item \verb+\TTwhile+ donne \TTwhile.
    \item \verb+\TTrepeat+ donne \TTrepeat.
    \item \verb+\TTswitch+ donne \TTswitch.
\end{enumerate}

\begin{center}
	Liste des commandes de type \myquote{algorithme}.
\end{center}

\begin{enumerate}
    \item \verb+\ALif+ donne \ALif.
    \item \verb+\ALfor+ donne \ALfor.
    \item \verb+\ALwhile+ donne \ALwhile.
    \item \verb+\ALrepeat+ donne \ALrepeat.
    \item \verb+\ALswitch+ donne \ALswitch.
\end{enumerate}
% == Main tools - END == %




\section{Des outils additionnels pour les algorithmes} \label{algo-extra}

\subsection{Convention en bosses de chameau}

Le package \verb+algorithm2e+ utilise, et abuse
\footnote{
	Ce type de convention est un peu pénible à l'usage.
},
de la notation en bosses de chameau comme par exemple avec \verb+\uIf+ et \verb+\Return+ au lieu de \verb+\uif+ et \verb+\return+.
Par souci de cohérence, les nouvelles macros ajoutées par \verb+lyalgo+ en lien avec les algorithmes utilisent aussi cette convention même si l'auteur aurait préféré proposer \verb+\putin+ et \verb+\forrange+ à la place de \verb+\PutIn+ et \verb+\ForRange+ par exemple.




%\section{Des outils pour les algorithmes} \label{algo-extra}

\subsection{Affectations}

Les affectations simples classiques $x \Store 3$ et $3 \PutIn x$ se tapent \verb+$x \Store 3$+ et \verb+$3 \PutIn x$+ respectivement où les macros \verb+\Store+ et \verb+\PutIn+ sont des opérateurs mathématiques.

\medskip

Il existe aussi les macros \verb+\MStore+ et \verb+\MPutIn+ pour des affectations multiples en parallèle comme dans $a, b, c \MStore x, y, z$ ou $x, y, z \MPutIn a, b, c$ pour indiquer que les dernières valeurs de $x$, $y$ et $z$ sont affectées aux variables $a$, $b$ et $c$.
La multi-affectation se faisant en parallèle, le résultat de $a, b, c \MStore 2, a + b, c - b$ ne sera pas semblable à celui de $a \Store 2$ suivi de $b \Store a + b$, puis de $c \Store c - b$ car dans le second cas les variables $a$ et $b$ évoluent avant de nouvelles affectations simples.




%\section{Des outils pour les algorithmes} \label{algo-extra}

\subsection{Listes}

\begin{frame-gene}[AVERTISSEMENT -- Premier indice]
	\centering\itshape
	Pour le package, les indices des listes commencent toujours à un. 
\end{frame-gene}


\subsubsection{Opérations de base.}

Voici les premières macros pour travailler avec des listes c'est à dire des tableaux de taille modifiable.

\begin{enumerate}
	\item \textit{Liste vide.}

		  \verb+\EmptyList+ imprime une liste vide $\EmptyList$.


	\item \textit{Liste en extension.}

		  \verb+\List{4 ; 7 ; 7 ; -1}+ produit $\List{4 ; 7 ; 7 ; -1}$.


	\item \textit{Le $k$\ieme{} élément d'une liste.}

		  \verb+\ListElt{L}{1}+ produit $\ListElt{L}{1}$.


	\item \textit{La sous-liste des éléments jusqu'à celui à la position $k$.}

		  \verb+\ListUntil{L}{2}+ produit $\ListUntil{L}{2}$.


	\item \textit{La sous-liste des éléments à partir de celui à la position $k$.}

		  \verb+\ListFrom{L}{2}+ produit $\ListFrom{L}{2}$.


	\item \textit{Concaténer deux listes.}

		  \verb+\AddList+ est l'opérateur binaire $\AddList$ qui permet d'indiquer la concaténation de deux listes.


	\item \textit{Taille ou longueur d'une liste.}

		  La macro \verb+\Len(L)+ produit $\Len(L)$.
\end{enumerate}



\subsubsection{Modifier une liste -- Versions textuelles}

\begin{enumerate}
	\item \textit{Ajout d'un nouvel élément à droite.}

	      \verb+\Append{L}{5}+ produit \myquote{\Append{L}{5}}
	      \footnote{
		       Le verbe anglais \myquote{append} signifie \myquote{ajouter}.
		  }.


	\item \textit{Ajout d'un nouvel élément à gauche.}

	      \verb+\Prepend{L}{5}+ produit \myquote{\Prepend{L}{5}}
	      \footnote{
		       Le verbe anglais \myquote{prepend} signifie \myquote{préfixer}.
		  }.


	\item \textit{Extraction d'un élément.}

	      \verb+\PopAt{L}{3}+ produit \myquote{\PopAt{L}{3}}.
\end{enumerate}



\subsubsection{Modifier une liste -- Versions POO}

Les versions étoilées des macros précédentes fournissent une autre mise en forme à la fois concise et aisée à comprendre
\footnote{
	L'opérateur point \POOpoint{} est défini dans la macro \texttt{\textbackslash{}POOpoint}.
}
avec une syntaxe de type POO
\footnote{
	\myquote{POO} est l'acronyme de \myquote{Programmation Orientée Objet}.
}.


\begin{enumerate}
	\item \textit{Ajout d'un nouvel élément à droite.}

	      \verb+\Append*{L}{5}+ fournit \Append*{L}{5}.


	\item \textit{Ajout d'un nouvel élément à gauche.}

	      \verb+\Prepend*{L}{5}+ fournit \Prepend*{L}{5}.


	\item \textit{Extraction d'un élément.}

	      \verb+\PopAt*{L}{3}+ fournit \PopAt*{L}{3}.
\end{enumerate}



\subsubsection{Modifier une liste -- Versions symboliques}

Des versions doublement étoilées permettent d'obtenir des notations symboliques qui sont très efficaces lorsque l'on rédige les algorithmes à la main
\footnote{
	L'opérateur $\AddList$ est défini dans la macro \texttt{\textbackslash{}AddList}.
}.

\begin{enumerate}
	\item \textit{Ajout d'un nouvel élément à droite.}

	      \verb+\Append**{L}{5}+ donne \Append**{L}{5}.


	\item \textit{Ajout d'un nouvel élément à gauche.}

	      \verb+\Prepend**{L}{5}+ donne \Prepend**{L}{5}.


	\item \textit{Extraction d'un élément -- Version pseudo-automatique.}

	      \verb+\PopAt**{L}{3}+ donne \PopAt**{L}{3} avec un calcul fait automatiquement par la macro.
	      Bien entendu \verb+\PopAt**{L}{1}+ produit \PopAt**{L}{1} au lieu de $L \Store \ListUntil{L}{0} \AddList \ListFrom{L}{2}$ puisque pour le package les indices des listes commencent toujours à un.
	      
	      Il est autorisé de taper \verb+\PopAt**{L}{k}+ pour obtenir \PopAt**{L}{k}. Par contre, \verb+\PopAt**{L}{k-1}+ aboutit au truc très moche \PopAt**{L}{k-1}. 
	      Les items suivants expliquent comment gérer à la main les cas problématiques via des macros plus généralistes.

	      \smallskip

	      \emph{\textbf{Attention !} On notera que contrairement aux versions \emph{\texttt{\textbackslash{}PopAt}} et \emph{\texttt{\textbackslash{}PopAt*}}, l'écriture symbolique agit juste sur la liste d'un point de vue algorithmique. Si besoin, avec \emph{\texttt{\textbackslash{}PopAt**}} il faudra donc indiquer au préalable où stocker l'élément extrait via $\dots \Store \ListElt{L}{k}$.}


	\item \textit{Extraction d'éléments consécutifs.}

	      Lorsque les calculs automatiques ne sont pas faisables, on devra tout indiquer comme dans \verb+\KeepLR{L}{k - 2}{k}+
	      \footnote{
	      	Le nom de la macro vient de \myquote{keep left and right} soit \myquote{garder à droite et à gauche}.
		  }
		  afin d'avoir \KeepLR{L}{k - 2}{k} qui est bien mieux que ce que nous avions obtenu ci-dessus : \PopAt**{L}{k-1}.


	\item \textit{Extractions juste à droite, ou juste à gauche.}

	      \verb+\KeepL{L}{k}+ permet d'afficher \KeepL{L}{k} et \verb+\KeepR{L}{k}+ permet quant à lui d'écrire \KeepR{L}{k}
	      \footnote{
	      	Les noms des macros viennent de \myquote{keep left} et \myquote{keep right} soit \myquote{garder à gauche} et \myquote{garder à droite}.
		  }.
\end{enumerate}



\subsubsection{Parcourir une liste}

Les macros \verb+\ForInList+ et \verb+\ForInListRev+ facilitent la rédaction de boucle sur une liste parcourue de façon déterministe.


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \ForInList{e}{L}{
    Instruction 1
  }
\end{algo}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\begin{algo}
  \ForInList{e}{L}{
    Instruction 1
  }
\end{algo}
\vfill\null
\end{multicols}


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \ForInListRev{e}{L}{
    Instruction 1
  }
\end{algo}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\begin{algo}
  \ForInListRev{e}{L}{
    Instruction 1
  }
\end{algo}
\vfill\null
\end{multicols}




%\section{Des outils pour les algorithmes} \label{algo-extra}

\subsection{Boucles sur des entiers consécutifs}

Une boucle \verb+POUR+ peut s'écrire de façon succincte via \verb+\ForRange*+, ou bien de façon non ambigüe via \verb+\ForRange+ non étoilée. Voici ce que cela donne.


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \ForRange*{a}{0}{12}{
    Instruction 1
  }
\end{algo}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\begin{algo}
  \ForRange*{a}{0}{12}{
    Instruction 1
  }
\end{algo}
\vfill\null
\end{multicols}


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \ForRange{a}{0}{12}{
    Instruction 1
  }
\end{algo}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\begin{algo}
  \ForRange{a}{0}{12}{
    Instruction 1
  }
\end{algo}
\vfill\null
\end{multicols}


\vspace{-1em}

Pour en finir avec les boucles, l'exemple suivant montre comment obtenir une écriture symbolique. On utilise la macro \verb+\CSinterval+ proposée par le package \verb+lymath+.


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algo}
  \For{$a \in \CSinterval{0}{12}$}{
    Instruction 1
  }
\end{algo}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\begin{algo}
  \For{$a \in \CSinterval{0}{12}$}{
    Instruction 1
  }
\end{algo}
\vfill\null
\end{multicols}




\section{Ordinogrammes}

\subsection{C'est quoi un ordinogramme} \label{section:flowchart-firstexa}

Les ordinogrammes
\footnote{
    Le mot \myquote{ordinogramme} vient des mots \myquote{ordinateur}, du latin \myquote{ordinare} soit \myquote{mettre en ordre}, et du grec ancien \myquote{gramma} soit \myquote{lettre, écriture}.
}
sont des diagrammes que l'on peut utiliser pour expliquer des algorithmes très simples
\footnote{
    Cet outil pédagogique montre très vite ses limites. Essayez par exemple de tracer un ordinogramme pour expliquer comment résoudre une équation du 2\ieme{} degré.
}.
Voici un exemple expliquant comment résoudre $a x^2 + b = 0$, une équation en $x$, lorsque $a \neq 0$ et $b \neq 0$ : le code utilisé est donné plus tard dans la section \ref{section:flowchart-firstexa-code} \emph{(ce code sera très aisé à comprendre une fois lues les sections à venir)}.

\begin{center}
    \small
    \input{examples/merly-2nd-degree.tkz}
\end{center}


% -------------- %


\subsection{L'environnement \texttt{algochart}}

Tous les codes seront placés dans l'environnement \verb+algochart+ qui fait appel à \verb+TiKz+ qui fait le principal du travail
\footnote{
	\texttt{algochart} vient de la contraction de \myquote{algotithmic} et \myquote{flowchart} soit \myquote{algotithmique} et \myquote{diagramme} en anglais.
}.
\verb+lyalgo+ définit juste quelques styles et quelques macros pour faciliter la saisie des ordinogrammes.
Il faut alors travailler avec les macros \verb+\node+ et \verb+\path+ proposées par \verb+TiKz+.


% -------------- %


\subsection{Convention pour les noms des styles et des macros}

Toutes les fonctionnalités proposés par \verb+lyalgo+ seront nommées en utilisant le préfixe \verb+ac+ pour \verb+algochart+.


% -------------- %


\subsection{Les styles proposés}

\begin{frame-gene}[AVERTISSEMENT -- Normes adaptées]
	\centering\itshape
	A la norme officielle, nous avons préféré un style plus percutant

	où les formes des cadres sont bien différenciées.
\end{frame-gene}



\subsubsection{Entrée et sortie}

L'entrée et la sortie de l'algorithme sont représentés par des ovales comme dans l'exemple ci-après. Par convention, l'entrée se situe tout en haut de l'ordinogramme, et la sortie tout en bas.
Indiquons que \verb+io+ dans \verb+acio+ fait référence à \myquote{input / output} soit \myquote{entrée / sortie} en anglais.

\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  \node[acio] {Entrée ou sortie};
\end{algochart}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\medskip

\small
\begin{algochart}
  \node[acio] {Entrée ou sortie};
\end{algochart}
\vfill\null
\end{multicols}


\vspace{-1em}

Dans le code ci-dessus, nous utilisons le style \verb+acio+ en l'indiquant entre des crochets.
La machinerie \verb+TiKz+ permet de changer localement un réglage. Dans le code suivant, on modifie la largeur de l'ellipse pour n'avoir qu'une seule ligne de texte.

\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  \node[acio, text width = 8em]
       {Entrée ou sortie};
\end{algochart}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\medskip

\small
\begin{algochart}
  \node[acio, text width = 8em]
       {Entrée ou sortie};
\end{algochart}
\vfill\null
\end{multicols}



\subsubsection{Les instructions}

Dans l'exemple suivant, qui ne nécessite aucun commentaire
\footnote{
	Chercher l'erreur\dots
},
nous avons dû régler à la main la largeur du cadre.


\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  \node[acinstr, text width = 8em]
       {Une instruction};
\end{algochart}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\medskip

\small
\begin{algochart}
  \node[acinstr, text width = 8em]
       {Une instruction};
\end{algochart}
\vfill\null
\end{multicols}



\subsubsection{Les tests conditionnels via un exemple complet}

Nous allons voir comment obtenir le résult suivant. Ceci sera l'occasion d'expliquer comment placer les noeuds les uns par rapport aux autres, et aussi comment ajouter des connexions via la macro \verb+\path+ proposée par \verb+TiKz+.


\begin{center}
    \small
    \input{examples/if-absolute.tkz}
\end{center}


Voici le code utilisé pour obtenir l'ordinogramme ci-dessus. Nous donnons des explications après.

\medskip

\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  % Placement des noeuds.
  \node[acio]
       (input) {$n \in \NN$};
  \node[acif, below of = input]
       (is-neg) {$n < 0$ ?};

  \node[acinstr, right] at ($(is-neg) + (2.5,0)$)
       (neg) {$res \Store (-n)$};
  \node[acinstr, below of = is-neg]
       (not-neg) {$res \Store n$};

  \node[acio, below of = not-neg]
       (output) {$res$};

  % Ajout des connexions.
  \path[aclink] (input) -- (is-neg);

  \path[aclink] (is-neg) -- (neg) \aclabelabove{oui};
  \path[aclink] (is-neg) -- (not-neg) \aclabelright{non};

  \path[aclink] (not-neg) -- (output);
  \path[aclink] (neg)
             |- ([xshift = 3mm, yshift = 5mm] output.north)
             -- ([xshift = 3mm] output.north);
\end{algochart}
\end{verbatim}
\end{frame-gene}


Donnons des explications sur les points délicats du code précédent.

\begin{enumerate}
	\item \verb+\node[acio] (input) {$n \in \NN$}+
	      
	      \smallskip
	      Ici on définit \verb+input+ comme alias du noeud via \verb+(input)+, un alias utilisable ensuite pour différentes actions graphiques. 

	\medskip
	\item \verb+\node[acif, below of = input] (is-neg) {$n < 0$ ?}+

	      \smallskip
	      Ici on demande de placer le noeud nommé \verb+is-neg+ sous celui nommé \verb+input+ via \verb+below of = input+ où \myquote{below of} se traduit par \myquote{en dessous de} en anglais. Attention au signe égal dans \verb+below of = input+.
	
	\medskip
	\item \verb|\node[acinstr, right] at ($(is-neg) + (2.5,0)$) (neg) {$res \Store (-n)$}|
	      
	      \smallskip
	      Dans cette commande un peu plus mystique, l'emploi de \verb+right+ indique de se placer à gauche du dernier noeud.
	      Vient ensuite la cabalistique instruction \verb|at ($(is-neg) + (2.5,0)$)|.
	      Comme \myquote{at} signifie \myquote{à (tel endroit)} en anglais, on comprend que l'on demande de placer le noeud à une certaine position.
	       Il faut alors savoir que pour \verb+TiKz+ l'usage de \verb|($...$)| indique de faire un calcul qui ici est celui de coordonnées via \verb|(is-neg) + (2.5,0)|. 
	
	\medskip
	\item \verb+\path[aclink] (input) -- (is-neg)+
	      
	      \smallskip
	      Cette instruction plus simple demande de tracer, avec le style \verb+aclink+, un trait entre les noeuds \verb+input+ et \verb+is-neg+.
	
	\medskip
	\item \verb+\path[aclink] (is-neg) -- (neg) \aclabelabove{oui}+
	      
	      \smallskip
	      La nouveauté ici est l'utilisation de la macro \verb+\aclabelabove{oui}+ proposée par \verb+lyalgo+ pour placer ici du texte au début et au dessus de la connexion car \myquote{above} signifie \myquote{au-dessus} en anglais. 

	\medskip
	\item \verb+(neg) |- ([xshift = 3mm, yshift = 5mm] output.north)+
	      
	      \smallskip
	      Dans le dernier chemin, il y a deux astuces bien utiles. La première est \verb+([xshift = 3mm, yshift+
	      \verb+= 5mm] output.north)+ qui permet de se décaler relativement à un noeud.
	      La seconde chose utilisée est \verb+... |- ...+ qui demande de tracer une ligne formée de deux segments orthogonaux. Si l'on souhaite \myquote{échanger} segment vertical et segment horizontal, il suffit de passer par \verb+... -| ...+.
\end{enumerate}









\subsubsection{Les boucles}

L'exemple très farfelu qui suit montre comment dessiner une petite boucle en faisant ressortir les instructions liées au fonctionnement de la boucle \emph{(cet effet est impossible à obtenir en mode noir et blanc : voir la section \ref{section:bw-mode} à ce sujet)}.
On voit au passage la limite d'utilisabilité des ordinogrammes car ces derniers ne proposent pas de mise en forme efficace pour les boucles.


\begin{center}
    \small
    \input{examples/strange-loop.tkz}
\end{center}


Voici le code que nous avons utilisé. La seule vraie nouveauté est l'utilisation du style \verb+acifinstr+ pour mieux visualiser les instructions liées à la boucle.

\medskip

\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  % Placement des noeuds.
  \node[acifinstr]
       (loop-init) {$i \Store 0$};
  \node[acif, below of = loop-init]
       (loop-test) {$i \leq 10$ ?};

  \node[acifinstr, below of = loop-test]
       (loop-next) {$i \Store i+1$};

  \node[acinstr, right] at ($(loop-test) + (2.5,0)$)
       (loop-out) {\dots};

  % Ajout des connexions.
  \path[aclink] (loop-init) -- (loop-test);

  \path[aclink] (loop-test) -- (loop-out) \aclabelabove{non};

  \path[aclink] (loop-test) -- (loop-next) \aclabelright{oui};
  \path[aclink] (loop-next.west)
             -- ([xshift = -4em] loop-next.west)
             |- (loop-test.west);
\end{algochart}
\end{verbatim}
\end{frame-gene}


% -------------- %


\subsection{Passer de la couleur au noir et blanc, et vice versa} \label{section:bw-mode}

Pour l'impression papier, n'avoir que du noir et blanc peut rende service. Les commandes \verb+\acusebw+ et \verb+\acusecolor+ permettent d'avoir du noir et blanc ou de la couleur pour les ordinagrammes qui suivent l'utilisation de ces macros.

\newpage

\begin{multicols}{2}
\centering
\begin{frame-gene}[Code \LaTeX]
\begin{verbatim}
\begin{algochart}
  \node[acinstr] {Instruction};
\end{algochart}

\bigskip \acusebw

\begin{algochart}
  \node[acinstr] {Instruction};
\end{algochart}
\end{verbatim}
\end{frame-gene}
\vfill\null
\columnbreak
\textit{Mise en forme correspondante.}
\medskip

\small
\begin{algochart}
  \node[acinstr] {Instruction};
\end{algochart}

\bigskip \acusebw

\begin{algochart}
  \node[acinstr] {Instruction};
\end{algochart}
\vfill\null
\end{multicols}

\acusecolor


% -------------- %


\subsection{Code du tout premier exemple} \label{section:flowchart-firstexa-code}

Nous (re)donnons la version noir et blanc de l'ordinogramme présenté au début de la section \ref{section:flowchart-firstexa}.

\acusebw
\begin{center}
    \small
    \input{examples/merly-2nd-degree.tkz}
\end{center}
\acusecolor

Ce diagramme s'obtient via le code suivant.

\begin{frame-gene}[Code \LaTeX{} utilisé]
\begin{verbatim}
\begin{algochart}
  % Placement des noeuds.
  \node[acio]
       (input) {$a x^2 + b$ avec $a \neq 0$ et $b \neq 0$};

  \node[acinstr, below of = input, text width =  6em]
       (square) {$q \Store \dfrac{-b}{a}$};

  \node[acif, below of = square]
       (is-square-neg) {$q < 0$ ?};

  \node[acinstr,left] at ($(is-square-neg) + (-3,0)$)
       (no-sol) {$rep \Store \EmptyList$};

  \node[acinstr,right] at ($(is-square-neg) + (3,0)$)
       (pos-sol) {$psol \Store \sqrt{q}$};

  \node[acinstr, below of = pos-sol, text width = 9em]
       (all-sol) {$rep \Store \List{psol , - psol}$};

  \node[acio, below of = is-square-neg] at ($(is-square-neg) + (0,-1.75)$)
       (output) {$rep$};

  % Ajout des connexions.
  \path[aclink] (input) -- (square);
  \path[aclink] (square) -- (is-square-neg);

  \path[aclink] (is-square-neg) -- (no-sol) \aclabelabove{oui};
  \path[aclink] (is-square-neg) -- (pos-sol) \aclabelabove{non};

  \path[aclink] (pos-sol) -- (all-sol);
  \path[aclink] (all-sol)
             |- ([xshift = 2mm, yshift = 5mm] output.north)
             -- ([xshift = 2mm]output.north);

  \path[aclink] (no-sol)
             |- ([xshift = -2mm, yshift = 5mm] output.north)
             -- ([xshift = -2mm] output.north);
\end{algochart}
\end{verbatim}
\end{frame-gene}




\section{Historique}

Nous ne donnons ici qu'un très bref historique de \verb+lyalgo+ côté utilisateur principalement.
Tous les changements sont disponibles uniquement en anglais dans le dossier \verb+change-log+ : voir le code source de \verb+lyalgo+ sur \verb+github+.

\begin{description}[leftmargin=1em]
    \setlength\itemsep{1em}


% --------------- %

    \item[2019-10-19] Nouvelle version mineure \verb+0.1.0-beta+.
    \begin{itemize}
        \item Ajout d'outils pour faciliter le dessin d'ordinogrammes via \verb+TiKz+.
    \end{itemize} 


% --------------- %

    \item[2019-10-18] Le documentation a enfin son journal des changements principaux.


% --------------- %

    \item[2019-09-03] Première version \verb+0.0.0-beta+ du package.
\end{description}



\end{document}
